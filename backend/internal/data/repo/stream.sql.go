// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: stream.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getStream = `-- name: GetStream :one
select s.id, s.title, s.description, s.frame_interval_ms, s.created_at, s.updated_at, count(f.id) as frame_count
from streams s left join frames f on f.stream_id = s.id
group by s.id
having s.id = $1
`

type GetStreamRow struct {
	ID              pgtype.UUID        `json:"ID"`
	Title           string             `json:"Title"`
	Description     string             `json:"Description"`
	FrameIntervalMs int32              `json:"FrameIntervalMs"`
	CreatedAt       pgtype.Timestamptz `json:"CreatedAt"`
	UpdatedAt       pgtype.Timestamptz `json:"UpdatedAt"`
	FrameCount      int64              `json:"FrameCount"`
}

func (q *Queries) GetStream(ctx context.Context, id pgtype.UUID) (GetStreamRow, error) {
	row := q.db.QueryRow(ctx, getStream, id)
	var i GetStreamRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FrameIntervalMs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FrameCount,
	)
	return i, err
}

const listStreams = `-- name: ListStreams :many
select s.id, s.title, s.description, s.frame_interval_ms, s.created_at, s.updated_at, count(f.id) as frame_count
from streams s left join frames f on f.stream_id = s.id
group by s.id
order by s.created_at desc
`

type ListStreamsRow struct {
	ID              pgtype.UUID        `json:"ID"`
	Title           string             `json:"Title"`
	Description     string             `json:"Description"`
	FrameIntervalMs int32              `json:"FrameIntervalMs"`
	CreatedAt       pgtype.Timestamptz `json:"CreatedAt"`
	UpdatedAt       pgtype.Timestamptz `json:"UpdatedAt"`
	FrameCount      int64              `json:"FrameCount"`
}

func (q *Queries) ListStreams(ctx context.Context) ([]ListStreamsRow, error) {
	rows, err := q.db.Query(ctx, listStreams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStreamsRow
	for rows.Next() {
		var i ListStreamsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FrameIntervalMs,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FrameCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStream = `-- name: UpdateStream :one
UPDATE streams s
SET
    updated_at = now(),
    title = $2,
    description = $3,
    frame_interval_ms = $4
WHERE s.id = $1
    RETURNING
    s.id,
    s.title,
    s.description,
    s.frame_interval_ms,
    s.created_at,
    s.updated_at,
    (
        SELECT count(f.id)
        FROM frames f
        WHERE f.stream_id = s.id
    ) AS frame_count
`

type UpdateStreamParams struct {
	ID              pgtype.UUID `json:"ID"`
	Title           string      `json:"Title"`
	Description     string      `json:"Description"`
	FrameIntervalMs int32       `json:"FrameIntervalMs"`
}

type UpdateStreamRow struct {
	ID              pgtype.UUID        `json:"ID"`
	Title           string             `json:"Title"`
	Description     string             `json:"Description"`
	FrameIntervalMs int32              `json:"FrameIntervalMs"`
	CreatedAt       pgtype.Timestamptz `json:"CreatedAt"`
	UpdatedAt       pgtype.Timestamptz `json:"UpdatedAt"`
	FrameCount      int64              `json:"FrameCount"`
}

func (q *Queries) UpdateStream(ctx context.Context, arg UpdateStreamParams) (UpdateStreamRow, error) {
	row := q.db.QueryRow(ctx, updateStream,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.FrameIntervalMs,
	)
	var i UpdateStreamRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FrameIntervalMs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FrameCount,
	)
	return i, err
}
